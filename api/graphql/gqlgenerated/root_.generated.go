// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgenerated

import (
	"api/ent/entgenerated"
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	UserPublicProfile() UserPublicProfileResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	EmailCredential struct {
		Email func(childComplexity int) int
		ID    func(childComplexity int) int
		Owner func(childComplexity int) int
	}

	LoginSession struct {
		ID            func(childComplexity int) int
		LastLoginTime func(childComplexity int) int
		Owner         func(childComplexity int) int
	}

	Mutation struct {
		ConfirmUserEmailSignup      func(childComplexity int, emailSignupToken string, handleName string, rawPassword string) int
		CreateProfilePhotoUploadURL func(childComplexity int, userID int, md5 string) int
		EmailLogin                  func(childComplexity int, email string, rawPassword string) int
		Logout                      func(childComplexity int) int
		ResetPassword               func(childComplexity int, email string) int
		UserEmailSignup             func(childComplexity int, email string) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Node             func(childComplexity int, id int) int
		Nodes            func(childComplexity int, ids []int) int
		RefreshUserToken func(childComplexity int) int
		User             func(childComplexity int, id int) int
		Users            func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *entgenerated.UserWhereInput) int
		Viewer           func(childComplexity int) int
	}

	User struct {
		EmailCredential func(childComplexity int) int
		ID              func(childComplexity int) int
		LoginSessions   func(childComplexity int) int
		PublicProfile   func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserPublicProfile struct {
		HandleName       func(childComplexity int) int
		ID               func(childComplexity int) int
		Owner            func(childComplexity int) int
		PhotoDownloadURL func(childComplexity int) int
	}

	UserToken struct {
		AuthToken    func(childComplexity int) int
		RefreshToken func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "EmailCredential.email":
		if e.complexity.EmailCredential.Email == nil {
			break
		}

		return e.complexity.EmailCredential.Email(childComplexity), true

	case "EmailCredential.id":
		if e.complexity.EmailCredential.ID == nil {
			break
		}

		return e.complexity.EmailCredential.ID(childComplexity), true

	case "EmailCredential.owner":
		if e.complexity.EmailCredential.Owner == nil {
			break
		}

		return e.complexity.EmailCredential.Owner(childComplexity), true

	case "LoginSession.id":
		if e.complexity.LoginSession.ID == nil {
			break
		}

		return e.complexity.LoginSession.ID(childComplexity), true

	case "LoginSession.lastLoginTime":
		if e.complexity.LoginSession.LastLoginTime == nil {
			break
		}

		return e.complexity.LoginSession.LastLoginTime(childComplexity), true

	case "LoginSession.owner":
		if e.complexity.LoginSession.Owner == nil {
			break
		}

		return e.complexity.LoginSession.Owner(childComplexity), true

	case "Mutation.confirmUserEmailSignup":
		if e.complexity.Mutation.ConfirmUserEmailSignup == nil {
			break
		}

		args, err := ec.field_Mutation_confirmUserEmailSignup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmUserEmailSignup(childComplexity, args["emailSignupToken"].(string), args["handleName"].(string), args["rawPassword"].(string)), true

	case "Mutation.createProfilePhotoUploadUrl":
		if e.complexity.Mutation.CreateProfilePhotoUploadURL == nil {
			break
		}

		args, err := ec.field_Mutation_createProfilePhotoUploadUrl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProfilePhotoUploadURL(childComplexity, args["userId"].(int), args["md5"].(string)), true

	case "Mutation.emailLogin":
		if e.complexity.Mutation.EmailLogin == nil {
			break
		}

		args, err := ec.field_Mutation_emailLogin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EmailLogin(childComplexity, args["email"].(string), args["rawPassword"].(string)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.resetPassword":
		if e.complexity.Mutation.ResetPassword == nil {
			break
		}

		args, err := ec.field_Mutation_resetPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetPassword(childComplexity, args["email"].(string)), true

	case "Mutation.userEmailSignup":
		if e.complexity.Mutation.UserEmailSignup == nil {
			break
		}

		args, err := ec.field_Mutation_userEmailSignup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserEmailSignup(childComplexity, args["email"].(string)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.refreshUserToken":
		if e.complexity.Query.RefreshUserToken == nil {
			break
		}

		return e.complexity.Query.RefreshUserToken(childComplexity), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(int)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["where"].(*entgenerated.UserWhereInput)), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "User.emailCredential":
		if e.complexity.User.EmailCredential == nil {
			break
		}

		return e.complexity.User.EmailCredential(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.loginSessions":
		if e.complexity.User.LoginSessions == nil {
			break
		}

		return e.complexity.User.LoginSessions(childComplexity), true

	case "User.publicProfile":
		if e.complexity.User.PublicProfile == nil {
			break
		}

		return e.complexity.User.PublicProfile(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserPublicProfile.handleName":
		if e.complexity.UserPublicProfile.HandleName == nil {
			break
		}

		return e.complexity.UserPublicProfile.HandleName(childComplexity), true

	case "UserPublicProfile.id":
		if e.complexity.UserPublicProfile.ID == nil {
			break
		}

		return e.complexity.UserPublicProfile.ID(childComplexity), true

	case "UserPublicProfile.owner":
		if e.complexity.UserPublicProfile.Owner == nil {
			break
		}

		return e.complexity.UserPublicProfile.Owner(childComplexity), true

	case "UserPublicProfile.photoDownloadUrl":
		if e.complexity.UserPublicProfile.PhotoDownloadURL == nil {
			break
		}

		return e.complexity.UserPublicProfile.PhotoDownloadURL(childComplexity), true

	case "UserToken.authToken":
		if e.complexity.UserToken.AuthToken == nil {
			break
		}

		return e.complexity.UserToken.AuthToken(childComplexity), true

	case "UserToken.refreshToken":
		if e.complexity.UserToken.RefreshToken == nil {
			break
		}

		return e.complexity.UserToken.RefreshToken(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputEmailCredentialWhereInput,
		ec.unmarshalInputLoginSessionWhereInput,
		ec.unmarshalInputUserPublicProfileWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/email_credential.graphqls", Input: `extend type Mutation {
  userEmailSignup(email: String!): Boolean
  confirmUserEmailSignup(emailSignupToken: String!, handleName: String!, rawPassword: String!): UserToken
  emailLogin(email: String!, rawPassword: String!): UserToken
  resetPassword(email: String!): Boolean
}`, BuiltIn: false},
	{Name: "../schemas/ent.graphqls", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  superuserProfileID: ID
  emailCredentialID: ID
  loginSessionIDs: [ID!]
  publicProfileID: ID
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type EmailCredential implements Node {
  id: ID!
  email: String!
  owner: User!
}
"""
EmailCredentialWhereInput is used for filtering EmailCredential objects.
Input was generated by ent.
"""
input EmailCredentialWhereInput {
  not: EmailCredentialWhereInput
  and: [EmailCredentialWhereInput!]
  or: [EmailCredentialWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
type LoginSession implements Node {
  id: ID!
  lastLoginTime: Time!
  owner: User!
}
"""
LoginSessionWhereInput is used for filtering LoginSession objects.
Input was generated by ent.
"""
input LoginSessionWhereInput {
  not: LoginSessionWhereInput
  and: [LoginSessionWhereInput!]
  or: [LoginSessionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """last_login_time field predicates"""
  lastLoginTime: Time
  lastLoginTimeNEQ: Time
  lastLoginTimeIn: [Time!]
  lastLoginTimeNotIn: [Time!]
  lastLoginTimeGT: Time
  lastLoginTimeGTE: Time
  lastLoginTimeLT: Time
  lastLoginTimeLTE: Time
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "api/ent/entgenerated.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for Users returned from the connection."""
    where: UserWhereInput
  ): UserConnection!
}
"""The builtin Time type"""
scalar Time
type User implements Node {
  id: ID!
  emailCredential: EmailCredential
  loginSessions: [LoginSession!]
  publicProfile: UserPublicProfile
}
"""A connection to a list of items."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User
  """A cursor for use in pagination."""
  cursor: Cursor!
}
type UserPublicProfile implements Node {
  id: ID!
  handleName: String!
  owner: User!
}
"""
UserPublicProfileWhereInput is used for filtering UserPublicProfile objects.
Input was generated by ent.
"""
input UserPublicProfileWhereInput {
  not: UserPublicProfileWhereInput
  and: [UserPublicProfileWhereInput!]
  or: [UserPublicProfileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """handle_name field predicates"""
  handleName: String
  handleNameNEQ: String
  handleNameIn: [String!]
  handleNameNotIn: [String!]
  handleNameGT: String
  handleNameGTE: String
  handleNameLT: String
  handleNameLTE: String
  handleNameContains: String
  handleNameHasPrefix: String
  handleNameHasSuffix: String
  handleNameEqualFold: String
  handleNameContainsFold: String
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """email_credential edge predicates"""
  hasEmailCredential: Boolean
  hasEmailCredentialWith: [EmailCredentialWhereInput!]
  """login_sessions edge predicates"""
  hasLoginSessions: Boolean
  hasLoginSessionsWith: [LoginSessionWhereInput!]
  """public_profile edge predicates"""
  hasPublicProfile: Boolean
  hasPublicProfileWith: [UserPublicProfileWhereInput!]
}
`, BuiltIn: false},
	{Name: "../schemas/user.graphqls", Input: `type UserToken {
  authToken: String!
  refreshToken: String!
}

extend type Query {
  viewer: User
  user(id: ID!): User
  refreshUserToken: UserToken
}

extend type Mutation {
  logout: Boolean!
  createProfilePhotoUploadUrl(userId: ID!, md5: String!): String
}
`, BuiltIn: false},
	{Name: "../schemas/user_public_profile.graphqls", Input: `extend type UserPublicProfile {
  photoDownloadUrl: String
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
