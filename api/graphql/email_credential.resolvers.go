package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"api/config"
	"api/ent/entgenerated"
	"api/ent/entgenerated/emailcredential"
	"api/ent/privacy/entviewer"
	"api/ent/privacy/token"
	"api/graphql/gqlgenerated"
	"api/intl"
	"api/intl/intlgenerated"
	"api/lib"
	"api/privacy/viewer"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"golang.org/x/crypto/bcrypt"
)

// UserEmailSignup is the resolver for the userEmailSignup field.
func (r *mutationResolver) UserEmailSignup(ctx context.Context, email string) (*bool, error) {
	tokenBuilder := lib.NewEmailSignupJwtTokenFactory(config.GetHmacConfig())
	emailSignupToken, err := tokenBuilder.Create(email)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctx, err)
	}

	urlBuilder := lib.NewClientPathFactory(config.GetUrlConfig())
	signupUrl := urlBuilder.CreateConfirmEmailSignupPath(emailSignupToken)

	err = lib.NewMailer(config.GetMailerConfig()).
		SendConfirmSignupEmailEmail(email, signupUrl.String())
	if err != nil {
		return nil, graphql.ErrorOnPath(ctx, err)
	}

	result := true
	return &result, nil
}

// ConfirmUserEmailSignup is the resolver for the confirmUserEmailSignup field.
func (r *mutationResolver) ConfirmUserEmailSignup(ctx context.Context, emailSignupToken string, handleName string, rawPassword string) (*gqlgenerated.UserToken, error) {
	err := lib.ValidateStrongPassword(rawPassword)
	if err != nil {
		return nil, err
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(rawPassword), bcrypt.DefaultCost)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctx, err)
	}

	tokenFactory := lib.NewEmailSignupJwtTokenFactory(config.GetHmacConfig())
	signupToken, err := tokenFactory.Parse(emailSignupToken)
	if err != nil {
		return nil, graphql.ErrorOnPath(
			ctx,
			intl.HandleIntlError(err, intlgenerated.COMMON_STRINGS__UNABLE_TO_PROCESS_JWT_TOKEN),
		)
	}
	email, exists := signupToken.GetEmail()
	if !exists {
		return nil, graphql.ErrorOnPath(
			ctx,
			&intl.InvalidJwtTokenError{},
		)
	}

	privacyToken := token.EmailSignupToken{
		Email: email,
	}
	ctxWithToken := token.NewContextWithSignupToken(ctx, &privacyToken)

	tx, err := r.client.Tx(ctxWithToken)
	if err != nil {
		lib.NewLogger("email_credential.resolvers.go").LogError(err)
		return nil, graphql.ErrorOnPath(ctx, errors.New(intlgenerated.COMMON_STRINGS__UNKNOWN_SERVER_ERROR))
	}

	entUtils := lib.NewEntUtils()
	user, err := tx.User.
		Create().
		Save(ctxWithToken)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctxWithToken, entUtils.RollbackTx(tx, err))
	}

	userCtx := viewer.NewContext(ctxWithToken, entviewer.NewUserViewerFromUser(user))
	_, err = tx.UserPublicProfile.
		Create().
		SetOwner(user).
		SetHandleName(handleName).
		Save(userCtx)
	if entgenerated.IsConstraintError(err) {
		return nil, graphql.ErrorOnPath(
			ctxWithToken,
			entUtils.RollbackTx(
				tx,
				errors.New(intlgenerated.PUBLIC_PROFILE__DUPLICATE_HANDLE_NAME),
			),
		)
	} else if err != nil {
		return nil, graphql.ErrorOnPath(ctxWithToken, entUtils.RollbackTx(tx, err))
	}

	_, err = tx.EmailCredential.
		Create().
		SetEmail(email).
		SetAlgorithm("bcrypt").
		SetPasswordHash(passwordHash).
		SetOwner(user).
		Save(ctxWithToken)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctxWithToken, entUtils.RollbackTx(tx, err))
	}
	err = tx.Commit()
	if err != nil {
		return nil, graphql.ErrorOnPath(ctxWithToken, entUtils.RollbackTx(tx, err))
	}

	emailCredentialManager := lib.NewEmailCredentialManager(config.GetAuthConfig())
	result, err := emailCredentialManager.Login(ctx, r.client, email, rawPassword)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctxWithToken, err)
	}
	return &gqlgenerated.UserToken{
		AuthToken:    result.AuthToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// EmailLogin is the resolver for the emailLogin field.
func (r *mutationResolver) EmailLogin(ctx context.Context, email string, rawPassword string) (*gqlgenerated.UserToken, error) {
	// Obtain credential and user records
	emailCredentialManager := lib.NewEmailCredentialManager(config.GetAuthConfig())
	result, err := emailCredentialManager.Login(ctx, r.client, email, rawPassword)
	if err != nil {
		return nil, graphql.ErrorOnPath(ctx, intl.HandleIntlError(err, intlgenerated.COMMON_STRINGS__UNKNOWN_SERVER_ERROR))
	}
	return &gqlgenerated.UserToken{
		AuthToken:    result.AuthToken,
		RefreshToken: result.RefreshToken,
	}, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, email string) (*bool, error) {
	var result bool

	liftedCtx := token.NewContextWithPerformingResetPasswordToken(ctx, email)
	credential, entErr := r.client.EmailCredential.Query().
		Where(emailcredential.Email(email)).
		Only(liftedCtx)
	if entErr != nil {
		result = true
		// We don't want to expose any data related to the input email such as whether the email is registered
		// So just return true for any loading error
		return &result, nil
	}

	tokenFactory := lib.NewUserTokenFactory()
	token, err := tokenFactory.CreateResetPasswordToken(credential)
	if err != nil {
		result = false
		return &result, graphql.ErrorOnPath(ctx, errors.New(err.GetIntlKey()))
	}

	clientPathFactory := lib.NewClientPathFactory(config.GetUrlConfig())
	url := clientPathFactory.CreateResetPasswordUrl(token)

	mailer := lib.NewMailer(config.GetMailerConfig())
	err = mailer.SendResetPasswordEmail(email, url.String())
	if err != nil {
		result = false
		return &result, graphql.ErrorOnPath(ctx, errors.New(err.GetIntlKey()))
	}

	result = true
	return &result, nil
}

// Mutation returns gqlgenerated.MutationResolver implementation.
func (r *Resolver) Mutation() gqlgenerated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
